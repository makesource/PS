
struct segment_tree { // with Lazy Propagation
private:
    int N, Z;
    vector<ll> tree;
    vector<ll> lazy;
    void update(int x, int L, int R, int range_L, int range_R, ll val, ll f(ll, ll)) {
        // x : node's index
        // L, R : current node's range
        // range_L, range_R : target range
        if (range_R < L || R < range_L) return ;
        if (L > R || range_L > range_R) return ;
        if (range_L <= L && R <= range_R) {
            lazy[x] = f(lazy[x], val);
            return ;
        }
        
        if (lazy[x] != DEFAULT) {
            lazy[x*2] = f(lazy[x*2], lazy[x]);
            lazy[x*2+1] = f(lazy[x*2+1], lazy[x]);
            lazy[x] = DEFAULT;
        }
        
        int M = (L + R) / 2;
        update(x*2, L, M, range_L, range_R, val, f);
        update(x*2+1, M+1, R, range_L, range_R, val, f);
        tree[x] = f(f(tree[x*2], lazy[x*2]), f(tree[x*2+1], lazy[x*2+1]));
    }
    ll find_range(int x, int L, int R, int range_L, int range_R, ll f(ll, ll)) {
        // x : node's index
        // L, R : current node's range
        // range_L, range_R : target range

        if (range_R < L || R < range_L) return DEFAULT;
        if (L > R || range_L > range_R) return DEFAULT;
        if (range_L <= L && R <= range_R) return f(tree[x],lazy[x]);
        
        int M = (L + R) / 2;
        if (lazy[x] != DEFAULT) {
            lazy[x*2] = f(lazy[x*2], lazy[x]);
            lazy[x*2+1] = f(lazy[x*2+1], lazy[x]);
            lazy[x] = DEFAULT;
        }
        
        ll val_L = find_range(x*2, L, M, range_L, range_R, f);
        ll val_R = find_range(x*2+1, M+1, R, range_L, range_R, f);
        return f(val_L, val_R);
    }
    
public:
    ll DEFAULT;
    segment_tree(int size, ll DEF) {
        N = size; DEFAULT = DEF;
        for (Z=1;Z<N;Z*=2);
        tree.resize(2*Z + 1);
        lazy.resize(2*Z + 1);
        for (int i=1;i<=2*Z;i++) tree[i] = DEFAULT;
    }
    void update(int L, int R, ll val, ll f(ll, ll)) { update(1, 1, N, L, R, val, f); }
    ll find_single(int X, ll f(ll, ll)) { return find_range(1, 1, N, X, X, f); }
    ll find_range(int L, int R, ll f(ll, ll)) { return find_range(1, 1, N, L, R, f); }
};

ll MAX(ll a,ll b) {
    return maxf(a,b);
}

